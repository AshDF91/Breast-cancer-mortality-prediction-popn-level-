******************************************************************************** 
* Title: Risk model fitting/IECV for endpoint 2 - Cox model  
*			   Risks of breast cancer mortality at population level   
* Input: "\\qrvfile1\OX129\OX129\data\final_datasets\OX129_endpoint2_imputed_final.dta" 
* Output:  
* Author: Ash Clift 
* Date: 25th January 2022 
* Version: 2 - added analyses without including ethnicity 20th May 2022. 
******************************************************************************** 

* NOTE - THE PROCESS IS FIRST RUN INCLUDING ETHNICITY AS A PREDICTOR, THEN AFTERWARDS, 
* EXCLUDING ETHNICITY AS A PREDICTOR, AS DETAILED IN MANUSCRIPT. *
 
******************************************************************************** 
*                             TABLE OF CONTENTS  
*    Including ethnicity as predictor 
* 1) FRACTIONAL POLYNOMIAL SELECTION 
*	2) FIT FULL MODEL, PREDICTOR SELECTION  
*	3) INTERNAL-EXTERNAL CROSS-VALIDATION RUN (INC. BASELINE FUNCTION) 
*	4) PERFORMANCE ASSESSMENT  
*
*    Ethnicity not included as a predictor 
* 5) FRACTIONAL POLYNOMIAL SELECTION 
*	6) FIT FULL MODEL, PREDICTOR SELECTION  
*	7) INTERNAL-EXTERNAL CROSS-VALIDATION RUN (INC. BASELINE FUNCTION) 
*	8) PERFORMANCE ASSESSMENT
******************************************************************************** 

 
******************************************************************************** 
*                          1) Fractional polynomials                           * 
******************************************************************************** 
* Open imputed dataset - missing values for BMI, Townsend, alcohol and smoking imputed *  
use "\\data\final_datasets\Endpoint_2\OX129_endpoint2_imputed_new.dta", clear  

* Endpoints defined in data prep - tab here for reference *  
tab endpoint  
summ time, det  

* Stset the data, stop follow-up at 10 years as seeking 10-year prediction horizon *  
mi stset time, failure(endpoint==1) exit(time 10) 

* Run the FP selection process - mfp approach. Optimal functional forms in complete case data *  
timer on 1  
mfp, all: stcox age baseline_bmi town_int 
timer off 1 
timer list  
timer clear  

* Note: non-linear terms selected for age and BMI; will leave Townsend score linear *  
* Plot fractional polynomial terms obtained *   
stcox Iage* 
predict age_hr, hr  
twoway fpfitci age_hr age, graphregion(color(white)) leg(off) xtitle("Age at cohort entry", size(medium)) ytitle("Hazard ratio", size(medium))  
graph save "Graph" "\\graphs\ep2_cox\FP_age_cox_EP2.gph", replace  
drop age_hr  

stcox Ibase*    // baseline BMI 
predict bmi_fp, hr  
twoway fpfitci bmi_fp baseline_bmi, graphregion(color(white)) leg(off) xtitle("Baseline BMI at cohort entry", size(medium)) ytitle("Hazard ratio", size(medium))  
graph save "Graph" "\\graphs\ep2_cox\FP_bmi_cox_EP2.gph", replace  
drop bmi_fp  

clear  
******************************************************************************** 
 

******************************************************************************** 
*              2) Fit full model - perform predictor selection                 * 
******************************************************************************** 
use "\\data\final_datasets\Endpoint_2\OX129_endpoint2_imputed_new.dta", clear  

* Repeat here to be wasserdicht *  
mi stset time, failure(endpoint==1) exit(time 10) 

* Generate FP terms in imputed datasets - use data obtained from mfp in the outputs above *  
mi passive: gen bmi_x = (exp(ln_bmi))/10  
gen age_x = age/10  
mi passive: gen double bmi_fp1 = (bmi_x^-2) - 0.15531752                  // make in each imputation
mi passive: gen double bmi_fp2 = ((bmi_x^-2) * ln(bmi_x)) - 0.1446226461  // make in each imputation 

gen double age_fp1 = (age_x^2) - 0.055476233 
gen double age_fp2 = (age_x^3) - 76.53138187 

* Fit full model with all candidate predictors, then select those associated  
* with an exponentiated coefficient (HR) > 1.1 or <0.9, with p<0.01 * 
cd "\\models\Endpoint_2\"  
timer clear  
timer on 1  
* Define global for all variables in case multilpy typed out * 
global stcox_covars = "age_fp* bmi_fp* town_int i.ethnicity i.fibrocystic i.endometriosis i.pcos  //
i.hysterectomy i.previous_gynae_cancer i.ocp i.recent_oestrogen i.past_oestrogen i.recent_combined  //
i.past_combined i.fh_breastca i.fh_gynaeca i.lungca i.bloodca i.thyroidca i.alcohol_cat6 i.smoke_cat //
i.type1dm i.type2dm i.ckd i.htn i.ihd i.cirrhosis i.lupus i.vasculitis i.psychosis i.anti_psychotic //
i.thiazide i.betablocker i.raa i.acei i.cablocker i.tca i.maoi i.ssri c.age_fp1##i.fh_breastca // 
c.age_fp2##i.fh_breastca" 

* Fit the model * 
mi estimate, dots eform: stcox $stcox_covars  
parmest, list(,) saving(Cox_endpoint2_parmest_preselection.dta, replace) eform label for(estimate min95 max95)  
timer off 1  
timer list  

* Re-run with selected predictors to form final model *  
global selected_covars_cox = "age_fp* bmi_fp* i.ethnicity i.fibrocystic i.lungca i.bloodca  //
i.smoke_cat i.type1dm i.type2dm i.ckd i.cirrhosis i.vasculitis i.psychosis i.anti_psychotic" 

mi estimate, dots eform: stcox $selected_covars_cox  

 
* Save the coefs and exponentiated coefs for plotting later * 
parmest, list(,) saving(Cox_endpoint2_parmest_final_coefs.dta, replace) label for(estimate min95 max95)  
parmest, list(,) saving(Cox_endpoint2_parmest_final_hr.dta, replace) eform label for(estimate min95 max95) 

* Estimate baseline survival function at 10 years to 'complete' the model * 
mi query   
local M = r(M)       // M = number of imputed datasets 
scalar base_surv = 0  // Set up empty scalar. Will loop over each imputation, estimate baseline function
mi xeq 1/`M': qui stcox $selected_covars_cox ; qui predict double basesurv, basesurv ; summ basesurv if _t<=10; scalar base_surv = base_surv + r(min) 
scalar base_surv = base_surv/`M'  
disp as txt "Pooled baseline survivor function over imputations = " as res base_surv  
gen baseline_surv_cox = base_surv 
summ baseline_surv_cox 
 
******************************************************************************** 
******************************************************************************** 

******************************************************************************** 
*                 3) Internal-external cross-validation run                    * 
******************************************************************************** 
********************** 
* Preparing for IECV *  
********************** 
* Need to generate a measure of FU time from entry to earliest of: 
* event/competing event/censoring/end of period 1/end of study *  

gen fu_start = enter3     // cohort entry date 
format fu_start %td 
gen fu_end = .  

gen timesplit = mdy(01,01,2010) // The cut-off between Period 1 nand Period 2 for IECV
format timesplit %td 
tab period, m     // number of people entering cohort in each time period (Period 1 or 2) 

replace fu_end = min(exit3date, timesplit) if period==1  // Truncate follow-up at timesplit if needed. Otherwise, if exit date is before this, leave it 
replace fu_end = exit3date if period==2   // If in period 2, cannot spill follow-up nito next period... so leave exit date as is. 
format fu_end %td  

gen follow_up = fu_end-fu_start    // duration of follow-up in IECV setting 
summ follow_up, det  
 
* Overall even counts, any time in study period *  
tab endpoint  

* Generate new event indicator for IECV - event only counts if within the period in which they entered *
* IECV is emulating two wholly distinct datasets * 
gen iecv_event = 0  
replace iecv_event = 1 if period==1 & endpoint==1 & exit3date<timesplit  // entered in P1, died of breastca, and that happened during P1  
replace iecv_event = 1 if period==2 & endpoint==1     // entered in P2, and died of breastca before end of study period 

replace iecv_event = 2 if period==1 & endpoint==2 & exit3date<timesplit    // entered P1, died of other cause, and that death occurred during P1  
replace iecv_event = 2 if period==2 & endpoint==2  // entered in P2, died of other cause before end of follow-up

tab period  
tab iecv_event  
tab period iecv_event  

* quick quality checks *  
tab endpoint if period==1  
tab iecv_event if period==1  
tab iecv_event if period==2 

* Estimate baseline survival function in period 1 data- used for later computation 
* of predicted risks in Period 2 by combining with linear predictors from IECV * 
* Same system as above - want to emulate distinct cohorts * 

replace follow_up = follow_up/365.25 
mi stset follow_up if period==1, failure(iecv_event==1) exit(time 10) 
mi query  
local M = r(M) 
scalar period1_base_surv = 0  
mi xeq 1/`M': qui stcox $selected_covars_cox ; qui predict double basesurv, basesurv ; summ basesurv if _t<=10; scalar period1_base_surv = period1_base_surv + r(min) 
scalar period1_base_surv = period1_base_surv/`M'  
disp as txt "Pooled baseline survivor function over imputations = " as res period1_base_surv  
gen period1_baseline_surv_cox = period1_base_surv 
summ period1_baseline_surv_cox   

* stset the data for the IECV - take into account the event and time *  
mi stset follow_up, failure(iecv_event==1) exit(time 10)            // 10-yr prediction horizon

************ 
* Run IECV * 
************  

* Save dataset, then convert to flong format so that imputation-specific linear  
* predictor are kept (storecompleted option) *  
save "\\data\final_datasets\Endpoint_2\OX129_endpoint2_imputed_IECV.dta", replace  
mi convert flong  

* Generate new variables in which to store held out predictions*  
* Want to keep linear predictor (can be converted into HR later) * 
* Then, we can use them for the pooled overall metrics, but also to calculate centre-specific estimates *   
gen iecv_xb = .   

* Loop over each region, fit model, make predictions in the held out region's data. *  
cd "\\estimates\" 

* Run the IECV loop *   
timer clear  
timer on 2  

forval x = 1(1)10 {  
mi estimate, dots saving(myestiecv_ep2cox, replace): stcox $selected_covars_cox if (sha1!=`x' & period==1) 
mi predict double xb if (sha1==`x' & period==2) using myestiecv_ep2cox, xb storecompleted  
replace iecv_xb = xb if iecv_xb==.  
drop xb  
display `x' 
} 

timer off 2  
timer list  

summ iecv_xb, det   // distribution of linear predictors 
count if iecv_xb==. // number of missings equals the number of people in Period 1   

tab period  
keep if period==2   // save memory, only keep 'validation data' 

* Save updated dataset: save predictions, and then can use for the model evaluation*  
save "\\data\final_datasets\Endpoint_2\OX129_endpoint2_imputed_IECV.dta" , replace 
clear  

******************************************************************************** 
******************************************************************************** 


******************************************************************************** 
*                         4) PERFORMANCE ASSESSMENT                            *  
******************************************************************************** 
use "\\data\final_datasets\Endpoint_2\OX129_endpoint2_imputed_IECV.dta", clear  

**************************************************************** 
** Calculate pooled metrics from predictions on held-out data ** 
**************************************************************** 
* Calibration slope overall in Period 2 data *  
mi stset follow_up, failure(iecv_event==1) exit(time 10)  
mi estimate, dots: stcox iecv_xb  

* Calibration-in-the-large in Period 2 data *  
mi estimate, dots: stcox iecv_xb, offset(iecv_xb)  

* Discrimination: Harrell's C in the Period 2 data *  
gen iecv_hr = exp(iecv_xb)  
gen iecv_invhr = 1/iecv_hr   
gen censind = 1-_d if _st==1 
mi estimate, cmdok dots: somersd _t iecv_invhr if _st==1, cenind(censind) tdist transf(c) 

******************************************************************************************** 
** Generate programs that apply Royston & Sauerbrai's D statisic and R-squared in mi data ** 
********************************************************************************************  

* D statistic * 

cap program drop DStat                // define program, command is DStat 
program DStat, eclass properties(mi)  // eclass, uses multiply imputed data 
args model covariate                  // takes arguments model and covariate 
str2d: `model' `covariate'            // pu these arguments into str2d command 
tempname b V                          // name matrix that results will be put into 
mat `b' = r(D)                        // beta = point estimate for D statistic
mat `V' = r(sD)^2                     // square the standard error of D - give the variance to the program
local N = r(N)  
mat colnames `b' = D                  // name columns and rows of the results matrix consistently 
mat colnames `V' = D  
mat rownames `b' = D  
mat rownames `V' = D 
ereturn post `b' `V' , obs(`N')       // program returns these
ereturn local cmd "DStat"             //  Ouput of command 
ereturn local title "Royston & Sauerbrai's D" 
end  

* R-squared * 

cap program drop RSquared                // Similar to above for D statistic, but we want the R-squared 
program RSquared, eclass properties(mi)  // works on imputed data, 
args model covariate  
str2d: `model' `covariate'               // Feed these arguments to the str2d package 
tempname b V  
mat `b' = r(r2)                          // Grab the r-squared from the results table
mat `V' = r(r2se)^2                      // and its standard error, but square it to get variance 
local N = r(N)  
mat colnames `b' = R-squared  
mat colnames `V' = R-squared  
mat rownames `b' = R-squared  
mat rownames `V' = R-squared 
ereturn post `b' `V' , obs(`N') 
ereturn local cmd "RSquared"            // Return 
ereturn local title "Royston & Sauerbrai's R-squared" 
end  


******************************** 
* Performance by ethnic groups *  
******************************** 
* Discrimination in different ethnic groups: Harrell's C *  
forval x = 1(1)6 { 
mi estimate, cmdok dots esampvaryok: somersd _t iecv_invhr if (_st==1 & ethnicity==`x'), cenind(censind) tdist transf(c) 
  } 

 
* Calibration slope in different ethnic groups  *  
forval x = 1(1)6 {  
mi estimate, dots esampvaryok: stcox iecv_xb if ethnicity==`x'  
} 


* Calibration-in-the-large in different ethnic groups  *  
forval x = 1(1)6 {  
mi estimate, dots esampvaryok: stcox iecv_xb if ethnicity==`x', offset(iecv_xb)  
} 

***************************** 
* Performance in age groups * 
*****************************  
gen agegroup = 1  
replace agegroup = 2 if age>=30  
replace agegroup = 3 if age>=40  
replace agegroup = 4 if age>=50  
replace agegroup = 5 if age>=60  
replace agegroup = 6 if age>=70  
replace agegroup = 7 if age>=80  
tab agegroup  

* Discrimination across age groups - Harrell's C*  
forval x = 1(1)7 { 
mi estimate, cmdok dots: somersd _t iecv_invhr if (_st==1 & agegroup==`x'), cenind(censind) tdist transf(c) 
  } 

* Calibration slope across age groups *  
forval x = 1(1)7 {  
mi estimate, dots: stcox iecv_xb if agegroup==`x' 
} 

* Calibration-in-the-large across age groups *  
forval x = 1(1)7 {  
mi estimate, dots: stcox iecv_xb if agegroup==`x', offset(iecv_xb) 
} 

************************************************************************ 
* Different age groups - pre-screen, screening age, post-screening age * 
************************************************************************  
gen age_group3 = 1  
replace age_group3 = 2 if age>=50  
replace age_group3 = 3 if age>70  
tab age_group3 if _mi_m==0  
tab _d age_group3 if _mi_m==0  
 
* Discrimination across age groups - Harrell's C*  
forval x = 1(1)3 { 
mi estimate, cmdok dots: somersd _t iecv_invhr if (_st==1 & age_group3==`x'), cenind(censind) tdist transf(c) 
  } 

* Calibration slope across age groups *  
forval x = 1(1)3 {  
mi estimate, dots: stcox iecv_xb if age_group3==`x' 
} 

* Calibration-in-the-large across age groups *  
forval x = 1(1)3 {  
mi estimate, dots: stcox iecv_xb if age_group3==`x', offset(iecv_xb)  
} 

************************************************** 
**     Region-level heterogeneity and results   ** 
************************************************** 
cd "\\estimates\"  

*************************** 
* GT IECV for Harrell's C * 
*************************** 
capture postutil clear    
tempname C_EP2regioncox 
postfile `C_EP2regioncox' beta st_err val_size using C_EP2regioncox.dta , replace 

  forval x = 1(1)10 { 
  mi estimate, cmdok dots: somersd _t iecv_invhr if (_st==1 & sha1==`x'), cenind(censind) tdist transf(c)  // estimate Harrell's C 
  local beta = r(table)[1,1]            // the point estimate for Harrell's C in this region, in period 2 data 
  local st_err = r(table)[2,1]          // the standard error  
  local val_size = e(N)                 // sample size in this region 
  post `C_EP2regioncox' (`beta') (`st_err') (`val_size')  // post these to external file for later meta-analysis 
  } 
  
  postclose `C_EP2regioncox'  
   
********************************* 
* GT IECV for calibration slope * 
********************************* 
capture postutil clear    
tempname slope_EP2regioncox 
postfile `slope_EP2regioncox' slope slope_se val_size using slope_EP2regioncox.dta , replace  

  forval x = 1(1)10 { 
  mi estimate, dots: stcox iecv_xb if sha1==`x'     // estimate slope in each region in period 2 data 
  local slope = r(table)[1,1]                       // pint estimate for slope
  local slope_se = r(table)[2,1]                    // standard error of slope 
  local val_size = e(N)                             // sample size in this region 
  post `slope_EP2regioncox' (`slope') (`slope_se') (`val_size')  // post these to external file for later meta-analysis 
  } 
  
  postclose `slope_EP2regioncox'  

**************************************** 
* GT IECV for calibration-in-the-large * 
**************************************** 

capture postutil clear                              // same as for slope, but CITL is calculated using an offset term 
tempname citl_EP2regioncox 
postfile `citl_EP2regioncox' citl citl_se val_size using citl_EP2regioncox.dta , replace  

  forval x = 1(1)10 {  
  mi estimate, dots: stcox iecv_xb if sha1==`x', offset(iecv_xb)  
  local citl = r(table)[1,1] 
  local citl_se = r(table)[2,1] 
  local val_size = e(N) 
  post `citl_EP2regioncox' (`citl') (`citl_se') (`val_size') 
  }  
  
  postclose `citl_EP2regioncox' 

 
*************************************** 
* GT IECV for Royston & Sauerbrai's D * 
*************************************** 

capture postutil clear    
tempname D_EP2regioncox 
postfile `D_EP2regioncox' D D_se val_size using D_EP2regioncox.dta , replace  

  forval x = 1(1)10 {  
  preserve                        // program only runs if data preserved 
  keep if sha1==`x'               // preserve, then isolate the region of interest 
  mi estimate, dots: DStat stcox iecv_xb   // run the program to estimate D statistic in the imputed data - program pools it  
  local D = r(table)[1,1]                    // D statistic (Rubin's rule combined across datasets) 
  local D_se = r(table)[2,1]                 // standard error (Rubin's rules) 
  local val_size = e(N) 
  post `D_EP2regioncox' (`D') (`D_se') (`val_size')   
  restore 
  } 

  postclose `D_EP2regioncox' 


**************************************** 
* GT IECV for Royston & Sauerbrai's R2 * 
**************************************** 
capture postutil clear    
tempname R2_EP2regioncox 
postfile `R2_EP2regioncox' R2 R2_se val_size using R2_EP2regioncox.dta , replace  

forval x = 1(1)10 {  
  preserve  
  keep if sha1==`x'  
  mi estimate, dots: RSquared stcox iecv_xb  
  local R2 = r(table)[1,1] 
  local R2_se = r(table)[2,1] 
  local val_size = e(N) 
  post `R2_EP2regioncox' (`R2') (`R2_se') (`val_size') 
  restore  
  } 

  postclose `R2_EP2regioncox' 


*************************** 
* GT IECV for Brier Score * 
*************************** 

cap program drop brierscore  
program brierscore, eclass properties(mi)  
args covariates time  
stbrier `covariates', btime(`time') 
tempname b V  
mat `b' = e(b)  
mat `V' = e(V) 
local N = r(N)  
mat colnames `b' = Brier  
mat colnames `V' = Brier  
mat rownames `V' = Brier  
ereturn post `b' `V' , obs(`N') 
ereturn local cmd "brierscore" 
ereturn local title "Brier Score" 
end  

capture postutil clear    
tempname Brier_EP2regioncox 
postfile `Brier_EP2regioncox' Brier Brier_se val_size using Brier_EP2regioncox.dta , replace  

  forval x = 1(1)10 {  
  preserve  
  keep if sha1==`x'  
  mi estimate, dots: brierscore iecv_xb 10 
  local Brier = r(table)[1,1] 
  local Brier_se = r(table)[2,1] 
  local val_size = e(N) 
  post `Brier_EP2regioncox' (`Brier') (`Brier_se') (`val_size') 
  restore 
  } 

  postclose `Brier_EP2regioncox' 

******************************************************************************** 

save "\\data\final_datasets\Endpoint_2\OX129_endpoint2_imputed_IECV.dta", replace 

* Counts for number of events, and denominators inregion for the purposes of plotting forest plots
* after meta-analysis pooling of performance metrics * 
tab _d sha1 if period==2 & _mi_m==0  

clear  

***************** 
* Meta-analyses * 
*****************  
** Random effects meta-analysis pooled performance metrics *  
use "\\estimates\C_EP2regioncox.dta", clear  
input str50 region 
"East Midlands (138/176,360)" 
"East of England (143/227,079)" 
"London (458/1,690,339)" 
"North East (77/98,275)" 
"North West (505/815,303)" 
"South Central (307/625,953)" 
"South East (292/551,737)" 
"South West (341/578,496)" 
"West Midlands (349/520,826)" 
"Yorkshire & Humber (94/191,202)" 
end 
meta set beta st_err, studylab(region) 
meta summarize, random(sjonkman) se(khartung) predinterval(95) 
meta forestplot, random(sjonkman) se(khartung) predinterval(95) xline(0.5) 
graph save "Graph" "\\graphs\ep2_cox\EP2_harrellsC_cox.gph", replace  
clear  

use "\\estimates\slope_EP2regioncox.dta" , clear  
input str50 region 
"East Midlands (138/176,360)" 
"East of England (143/227,079)" 
"London (458/1,690,339)" 
"North East (77/98,275)" 
"North West (505/815,303)" 
"South Central (307/625,953)" 
"South East (292/551,737)" 
"South West (341/578,496)" 
"West Midlands (349/520,826)" 
"Yorkshire & Humber (94/191,202)" 
end 
meta set slope slope_se, studylab(region) 
meta summarize, random(sjonkman) se(khartung) predinterval(95) 
meta forestplot, random(sjonkman) se(khartung) predinterval(95) xline(1) 
graph save "Graph" "\\graphs\ep2_cox\EP2_slope_cox.gph", replace  
clear 

 
use "\\estimates\citl_EP2regioncox.dta" , clear  
input str50 region 
"East Midlands (138/176,360)" 
"East of England (143/227,079)" 
"London (458/1,690,339)" 
"North East (77/98,275)" 
"North West (505/815,303)" 
"South Central (307/625,953)" 
"South East (292/551,737)" 
"South West (341/578,496)" 
"West Midlands (349/520,826)" 
"Yorkshire & Humber (94/191,202)" 
end 
meta set citl citl_se, studylab(region) 
meta summarize, random(sjonkman) se(khartung) predinterval(95) 
meta forestplot, random(sjonkman) se(khartung) predinterval(95) xline(0) 
graph save "Graph" "\\graphs\ep2_cox\EP2_citl_cox.gph", replace  
clear 

 
use "\\estimates\D_EP2regioncox.dta" , clear  
input str50 region 
"East Midlands (138/176,360)" 
"East of England (143/227,079)" 
"London (458/1,690,339)" 
"North East (77/98,275)" 
"North West (505/815,303)" 
"South Central (307/625,953)" 
"South East (292/551,737)" 
"South West (341/578,496)" 
"West Midlands (349/520,826)" 
"Yorkshire & Humber (94/191,202)" 
end 
meta set D D_se, studylab(region) 
meta summarize, random(sjonkman) se(khartung) predinterval(95) 
meta forestplot, random(sjonkman) se(khartung) predinterval(95) 
graph save "Graph" "\\graphs\ep2_cox\EP2_D_cox.gph", replace  
clear 

 
use "\\estimates\R2_EP2regioncox.dta" , clear  
input str50 region 
"East Midlands (138/176,360)" 
"East of England (143/227,079)" 
"London (458/1,690,339)" 
"North East (77/98,275)" 
"North West (505/815,303)" 
"South Central (307/625,953)" 
"South East (292/551,737)" 
"South West (341/578,496)" 
"West Midlands (349/520,826)" 
"Yorkshire & Humber (94/191,202)" 
end 
meta set R2 R2_se, studylab(region) 
meta summarize, random(sjonkman) se(khartung) predinterval(95) 
meta forestplot, random(sjonkman) se(khartung) predinterval(95)  
graph save "Graph" "\\graphs\ep2_cox\EP2_R2_cox.gph", replace  
clear 

 
use "\\estimates\Brier_EP2regioncox.dta" , clear  
input str50 region 
"East Midlands (138/176,360)" 
"East of England (143/227,079)" 
"London (458/1,690,339)" 
"North East (77/98,275)" 
"North West (505/815,303)" 
"South Central (307/625,953)" 
"South East (292/551,737)" 
"South West (341/578,496)" 
"West Midlands (349/520,826)" 
"Yorkshire & Humber (94/191,202)" 
end 
meta set Brier Brier_se, studylab(region) 
meta summarize, random(sjonkman) se(khartung) predinterval(95) 
meta forestplot, random(sjonkman) se(khartung) predinterval(95)  
graph save "Graph" "\\graphs\ep2_cox\EP2_Brier_cox.gph", replace  
clear 

******************************************************************************** 

*****************************
* Smoothed calibration plot *
*****************************

use "\\data\final_datasets\Endpoint_2\OX129_endpoint2_imputed_IECV.dta", clear  

* Need to convert to wide (to use average iecv_xb), plot graph, close without saving *   
mi extract 0  
 
* Pseudovalues for failure function in Period 2 data - 'observed' event probs *  
stpsurv if period==2, failure at(10) gen(period2_pseudo) 
summ period2_pseudo, det  

* Generate predicted probabilities * 
gen iecv_risk = 1 - period1_baseline_surv_cox  ^exp(iecv_xb) 
summ iecv_risk, det  
drop if iecv_risk==. 

 
* Predicted probabilities - use the IECV-estimate linear predictors and combined with baseline  
* survival function estimated in Period 2 data earlier *  
running period2_pseudo iecv_risk, ci leg(off) nopts ysc(range(0 0.17)) xsc(range(0 0.17)) // 
ylab(0(0.05)0.17) xlab(0(.05)0.15) title("Smoothed calibration plot - Cox proportional hazards model", //
 size(small)) xtitle("Predicted event probability") ytitle("Observed event probability") graphregion(color(white))  

graph save "Graph" "\\graphs\ep2_cox\EP2_cox_smoothed_calibration.gph", replace  


clear 
******************************************************************************** 
********************************************************************************
********************************************************************************


*************************************************************************************
* PART TWO - COX MODELLING, BUT 'RACE BLIND', I.E. EXCLUDING ETHNICITY AS PREDICTOR *
*************************************************************************************

* As discussed in manuscript, most ethnic groups have coefs<0 * 
* Whilst 'model may want this, poses ethical considerations * 
* Repeat modelling without ethnicity as a candidate predictor, see what happens * 
* This code at times overwrites the save files above - so rename with appropriate suffix/prefix for record keeping * 

* Open the imputed data * 
use "\\data\final_datasets\Endpoint_2\OX129_endpoint2_imputed_new.dta", clear  

******************************************************************************** 
*              1) Fit full model - perform predictor selection                 * 
******************************************************************************** 

* Repeat here to be wasserdicht *  
mi stset time, failure(endpoint==1) exit(time 10) 

* Generate FP terms in imputed datasets *  
mi passive: gen bmi_x = (exp(ln_bmi))/10  
gen age_x = age/10  
mi passive: gen double bmi_fp1 = (bmi_x^-2) - 0.15531752   
mi passive: gen double bmi_fp2 = ((bmi_x^-2) * ln(bmi_x)) - 0.1446226461  

gen double age_fp1 = (age_x^2) - 0.055476233 
gen double age_fp2 = (age_x^3) - 76.53138187 
* Fit full model with all candidate predictors, then select those associated  
* with an exponentiated coefficient (HR) > 1.1 or <0.9, with p<0.01 * 

cd "\\models\Endpoint_2\"  
timer clear  
timer on 1 

* Global of candidate predictors, but ethnicity not included * 
global stcox_covars = "age_fp* bmi_fp* town_int i.fibrocystic i.endometriosis i.pcos i.hysterectomy //
i.previous_gynae_cancer i.ocp i.recent_oestrogen i.past_oestrogen i.recent_combined i.past_combined // 
i.fh_breastca i.fh_gynaeca i.lungca i.bloodca i.thyroidca i.alcohol_cat6 i.smoke_cat i.type1dm // 
i.type2dm i.ckd i.htn i.ihd i.cirrhosis i.lupus i.vasculitis i.psychosis i.anti_psychotic i.thiazide // 
i.betablocker i.raa i.acei i.cablocker i.tca i.maoi i.ssri c.age_fp1##i.fh_breastca c.age_fp2##i.fh_breastca" 

mi estimate, dots eform: stcox $stcox_covars  

parmest, list(,) saving(Cox_endpoint2_parmest_preselection_raceblind.dta, replace) eform label for(estimate min95 max95)  

timer off 1  
timer list  

* Re-run with selected predictors to form final model *  

global selected_covars_cox = "age_fp* bmi_fp* i.fibrocystic i.lungca i.bloodca i.smoke_cat i.type1dm //
i.type2dm i.ckd i.cirrhosis i.vasculitis i.psychosis i.anti_psychotic" 

mi estimate, dots eform: stcox $selected_covars_cox  

* Save model coefs and exponentiated coefs for plotting later * 
parmest, list(,) saving(Cox_endpoint2_parmest_final_coefs_raceblind.dta, replace) label for(estimate min95 max95)  
parmest, list(,) saving(Cox_endpoint2_parmest_final_hr_raceblind.dta, replace) eform label for(estimate min95 max95) 

* Estimate baseline survival function at 10 years to 'complete' the model * 
mi query  
local M = r(M) 
scalar base_surv = 0  
mi xeq 1/`M': qui stcox $selected_covars_cox ; qui predict double basesurv, basesurv ; summ basesurv if _t<=10; scalar base_surv = base_surv + r(min) 
scalar base_surv = base_surv/`M'  
disp as txt "Pooled baseline survivor function over imputations = " as res base_surv  
gen baseline_surv_cox = base_surv 
summ baseline_surv_cox 

******************************************************************************** 
******************************************************************************** 

******************************************************************************** 
*                 3) Internal-external cross-validation run                    * 
********************************************************************************  
********************** 
* Preparing for IECV *  
********************** 

* Need to generate a measure of FU time from entry to earliest of:  //
* event/competing event/censoring/end of period 1/end of study *  

gen fu_start = enter3  
format fu_start %td  
gen fu_end = .  
gen timesplit = mdy(01,01,2010) 
format timesplit %td 
tab period, m  
replace fu_end = min(exit3date, timesplit) if period==1  
replace fu_end = exit3date if period==2  
format fu_end %td  
gen follow_up = fu_end-fu_start 
summ follow_up, det  

* Overall event counts, any time in study period *  
tab endpoint  

* Generate new event indicator for IECV - event only within period *  
* Same as above code - get same numbers/results * 
gen iecv_event = 0  
replace iecv_event = 1 if period==1 & endpoint==1 & exit3date<timesplit   
replace iecv_event = 1 if period==2 & endpoint==1  
replace iecv_event = 2 if period==1 & endpoint==2 & exit3date<timesplit   
replace iecv_event = 2 if period==2 & endpoint==2  
tab period  
tab iecv_event  
tab period iecv_event  

* quick quality checks *  
tab endpoint if period==1  
tab iecv_event if period==1  
tab iecv_event if period==2 

* Estimate baseline survival function in period 1 data- used for later computation 
* of predicted risks in Period 2 by combining with linear predictors from IECV *  
* This baseline function will be different as centering on different set of covariates * 
replace follow_up = follow_up/365.25 
mi stset follow_up if period==1, failure(iecv_event==1) exit(time 10) 
mi query  
local M = r(M) 
scalar period1_base_surv = 0  
mi xeq 1/`M': qui stcox $selected_covars_cox ; qui predict double basesurv, basesurv ; summ basesurv if _t<=10; scalar period1_base_surv = period1_base_surv + r(min) 
scalar period1_base_surv = period1_base_surv/`M'  
disp as txt "Pooled baseline survivor function over imputations = " as res period1_base_surv  
gen period1_baseline_surv_cox = period1_base_surv 
summ period1_baseline_surv_cox   

* stset the data for the IECV - take into account the event and time *  
mi stset follow_up, failure(iecv_event==1) exit(time 10)  

************ 
* Run IECV * 
************  
* Save dataset, then convert to flong format so that imputation-specific linear  
* predictor are kept (storecompleted option). This overwrites the dataset obtained in 'ethnicity-including models' * 

save "\\data\final_datasets\Endpoint_2\OX129_endpoint2_imputed_IECV.dta", replace  
mi convert flong  

* Generate new variables in which to store held out predictions*  
* Want to keep linear predictor (can be converted into HR later) * 
* Then, we can use them for the pooled overall metrics, but also to calculate centre-specific estimates *   
gen iecv_xb = .   

* Loop over each region, fit model, estimate metrics on held out region data. Later, we present individual practice results *  
cd "\\estimates\" 

* Run the IECV loop *   
timer clear  
timer on 2  

forval x = 1(1)10 {  
mi estimate, dots saving(myestiecv_ep2cox, replace): stcox $selected_covars_cox if (sha1!=`x' & period==1) 
mi predict double xb if (sha1==`x' & period==2) using myestiecv_ep2cox, xb storecompleted  
replace iecv_xb = xb if iecv_xb==.  
drop xb  
display `x' 
} 

timer off 2  
timer list  

summ iecv_xb, det  
count if iecv_xb==.  
tab period  
keep if period==2   // save memory, only keep 'validation data' 

* Save updated dataset: save predictions, and then can use for the model evaluation*  
save "\\data\final_datasets\Endpoint_2\OX129_endpoint2_imputed_IECV.dta" , replace 
clear  

******************************************************************************** 
******************************************************************************** 
 
 
******************************************************************************** 
*                         4) PERFORMANCE ASSESSMENT                            *  
******************************************************************************** 

use "\\data\final_datasets\Endpoint_2\OX129_endpoint2_imputed_IECV.dta", clear  
 
**************************************************************** 
** Calculate pooled metrics from predictions on held-out data ** 
**************************************************************** 
* Calibration slope overall in Period 2 data *  
mi stset follow_up, failure(iecv_event==1) exit(time 10)  
mi estimate, dots: stcox iecv_xb  

* Calibration-in-the-large in Period 2 data *  
mi estimate, dots: stcox iecv_xb, offset(iecv_xb)  

* Discrimination: Harrell's C in the Period 2 data *  
gen iecv_hr = exp(iecv_xb)  
gen iecv_invhr = 1/iecv_hr   
gen censind = 1-_d if _st==1 
mi estimate, cmdok dots: somersd _t iecv_invhr if _st==1, cenind(censind) tdist transf(c) 
 
******************************************************************************************** 
** Generate programs that apply Royston & Sauerbrai's D statisic and R-squared in mi data ** 
********************************************************************************************  
* D statistic * 
cap program drop DStat  
program DStat, eclass properties(mi)  
args model covariate 
str2d: `model' `covariate' 
tempname b V  
mat `b' = r(D)  
mat `V' = r(sD)^2 
local N = r(N)  
mat colnames `b' = D  
mat colnames `V' = D  
mat rownames `b' = D  
mat rownames `V' = D 
ereturn post `b' `V' , obs(`N') 
ereturn local cmd "DStat" 
ereturn local title "Royston & Sauerbrai's D" 
end  

 
* R-squared *  
cap program drop RSquared  
program RSquared, eclass properties(mi)  
args model covariate  
str2d: `model' `covariate' 
tempname b V  
mat `b' = r(r2)  
mat `V' = r(r2se)^2 
local N = r(N)  
mat colnames `b' = R-squared  
mat colnames `V' = R-squared  
mat rownames `b' = R-squared  
mat rownames `V' = R-squared 
ereturn post `b' `V' , obs(`N') 
ereturn local cmd "RSquared" 
ereturn local title "Royston & Sauerbrai's R-squared" 
end  


******************************** 
* Performance by ethnic groups *  
******************************** 
* Discrimination in different ethnic groups: Harrell's C *  
forval x = 1(1)6 { 
mi estimate, cmdok dots esampvaryok: somersd _t iecv_invhr if (_st==1 & ethnicity==`x'), cenind(censind) tdist transf(c) 
  } 

* Calibration slope in different ethnic groups  *  
forval x = 1(1)6 {  
mi estimate, dots esampvaryok: stcox iecv_xb if ethnicity==`x'  
} 

* Calibration-in-the-large in different ethnic groups  *  
forval x = 1(1)6 {  
mi estimate, dots esampvaryok: stcox iecv_xb if ethnicity==`x', offset(iecv_xb)  
} 

***************************** 
* Performance in age groups * 
*****************************  
gen agegroup = 1  
replace agegroup = 2 if age>=30  
replace agegroup = 3 if age>=40  
replace agegroup = 4 if age>=50  
replace agegroup = 5 if age>=60  
replace agegroup = 6 if age>=70  
replace agegroup = 7 if age>=80  
tab agegroup  

* Discrimination across age groups - Harrell's C*  
forval x = 1(1)7 { 
mi estimate, cmdok dots: somersd _t iecv_invhr if (_st==1 & agegroup==`x'), cenind(censind) tdist transf(c) 
  } 

* Calibration slope across age groups *  
forval x = 1(1)7 {  
mi estimate, dots: stcox iecv_xb if agegroup==`x' 
} 

* Calibration-in-the-large across age groups *  
forval x = 1(1)7 {  
mi estimate, dots: stcox iecv_xb if agegroup==`x', offset(iecv_xb) 
} 


************************************************************************ 
* Different age groups - pre-screen, screening age, post-screening age * 
************************************************************************  
gen age_group3 = 1  
replace age_group3 = 2 if age>=50  
replace age_group3 = 3 if age>70  
tab age_group3 if _mi_m==0  
tab _d age_group3 if _mi_m==0  
 

* Discrimination across age groups - Harrell's C*  
forval x = 1(1)3 { 
mi estimate, cmdok dots: somersd _t iecv_invhr if (_st==1 & age_group3==`x'), cenind(censind) tdist transf(c) 
  } 

* Calibration slope across age groups *  
forval x = 1(1)3 {  
mi estimate, dots: stcox iecv_xb if age_group3==`x' 
} 

* Calibration-in-the-large across age groups *  
forval x = 1(1)3 {  
mi estimate, dots: stcox iecv_xb if age_group3==`x', offset(iecv_xb)  
} 

************************************************** 
**     Region-level heterogeneity and results   ** 
************************************************** 
cd "\\estimates\"  

*************************** 
* GT IECV for Harrell's C * 
*************************** 
capture postutil clear    
tempname C_EP2regioncox 
postfile `C_EP2regioncox' beta st_err val_size using C_EP2regioncox.dta , replace  

forval x = 1(1)10 { 
  mi estimate, cmdok dots: somersd _t iecv_invhr if (_st==1 & sha1==`x'), cenind(censind) tdist transf(c)  
  local beta = r(table)[1,1] 
  local st_err = r(table)[2,1] 
  local val_size = e(N) 
  post `C_EP2regioncox' (`beta') (`st_err') (`val_size') 
  } 

  postclose `C_EP2regioncox'  

********************************* 
* GT IECV for calibration slope * 
********************************* 
 
capture postutil clear    
tempname slope_EP2regioncox 
postfile `slope_EP2regioncox' slope slope_se val_size using slope_EP2regioncox.dta , replace  
   
  forval x = 1(1)10 { 
  mi estimate, dots: stcox iecv_xb if sha1==`x' 
  local slope = r(table)[1,1] 
  local slope_se = r(table)[2,1] 
  local val_size = e(N) 
  post `slope_EP2regioncox' (`slope') (`slope_se') (`val_size') 
  } 

postclose `slope_EP2regioncox'  

  
**************************************** 
* GT IECV for calibration-in-the-large * 
**************************************** 
capture postutil clear    
tempname citl_EP2regioncox 
postfile `citl_EP2regioncox' citl citl_se val_size using citl_EP2regioncox.dta , replace  

  forval x = 1(1)10 {  
  mi estimate, dots: stcox iecv_xb if sha1==`x', offset(iecv_xb)  
  local citl = r(table)[1,1] 
  local citl_se = r(table)[2,1] 
  local val_size = e(N) 
  post `citl_EP2regioncox' (`citl') (`citl_se') (`val_size') 
  } 

  postclose `citl_EP2regioncox'
   

*************************************** 
* GT IECV for Royston & Sauerbrei's D * 
*************************************** 
capture postutil clear    
tempname D_EP2regioncox 
postfile `D_EP2regioncox' D D_se val_size using D_EP2regioncox.dta , replace  

  forval x = 1(1)10 {  
  preserve  
  keep if sha1==`x' 
  mi estimate, dots: DStat stcox iecv_xb   
  local D = r(table)[1,1] 
  local D_se = r(table)[2,1] 
  local val_size = e(N) 
  post `D_EP2regioncox' (`D') (`D_se') (`val_size')   
  restore 
  } 
   
  postclose `D_EP2regioncox' 
 
 
**************************************** 
* GT IECV for Royston & Sauerbrai's R2 * 
**************************************** 
 
capture postutil clear    
tempname R2_EP2regioncox 
postfile `R2_EP2regioncox' R2 R2_se val_size using R2_EP2regioncox.dta , replace  
   
  forval x = 1(1)10 {  
  preserve  
  keep if sha1==`x'  
  mi estimate, dots: RSquared stcox iecv_xb  
  local R2 = r(table)[1,1] 
  local R2_se = r(table)[2,1] 
  local val_size = e(N) 
  post `R2_EP2regioncox' (`R2') (`R2_se') (`val_size') 
  restore  
  }   

  postclose `R2_EP2regioncox' 


*************************** 
* GT IECV for Brier Score * 
*************************** 

cap program drop brierscore  
program brierscore, eclass properties(mi)  
args covariates time  
stbrier `covariates', btime(`time') 
tempname b V  
mat `b' = e(b)  
mat `V' = e(V) 
local N = r(N)  
mat colnames `b' = Brier  
mat colnames `V' = Brier  
mat rownames `V' = Brier  
ereturn post `b' `V' , obs(`N') 
ereturn local cmd "brierscore" 
ereturn local title "Brier Score" 
end  

 
capture postutil clear    
tempname Brier_EP2regioncox 
postfile `Brier_EP2regioncox' Brier Brier_se val_size using Brier_EP2regioncox.dta , replace  
  forval x = 1(1)10 {  
  preserve  
  keep if sha1==`x'  
  mi estimate, dots: brierscore iecv_xb 10 
  local Brier = r(table)[1,1] 
  local Brier_se = r(table)[2,1] 
  local val_size = e(N) 
  post `Brier_EP2regioncox' (`Brier') (`Brier_se') (`val_size') 
  restore 
  } 

  postclose `Brier_EP2regioncox' 

 
******************************************************************************** 

 save "\\data\final_datasets\Endpoint_2\OX129_endpoint2_imputed_IECV.dta", replace 
 
tab _d sha1 if period==2 & _mi_m==0 

clear  

 
***************** 
* Meta-analyses * 
*****************  
** Random effects meta-analysis pooled performance metrics *  

use "\\estimates\C_EP2regioncox.dta", clear  
input str50 region 
"East Midlands (138/176,360)" 
"East of England (143/227,079)" 
"London (458/1,690,339)" 
"North East (77/98,275)" 
"North West (505/815,303)" 
"South Central (307/625,953)" 
"South East (292/551,737)" 
"South West (341/578,496)" 
"West Midlands (349/520,826)" 
"Yorkshire & Humber (94/191,202)" 
end 
meta set beta st_err, studylab(region) 
meta summarize, random(sjonkman) se(khartung) predinterval(95) 
meta forestplot, random(sjonkman) se(khartung) predinterval(95) xline(0.5) 
graph save "Graph" "\\graphs\ep2_cox\EP2_harrellsC_cox.gph", replace  
clear  

 
use "\\estimates\slope_EP2regioncox.dta" , clear  
input str50 region 
"East Midlands (138/176,360)" 
"East of England (143/227,079)" 
"London (458/1,690,339)" 
"North East (77/98,275)" 
"North West (505/815,303)" 
"South Central (307/625,953)" 
"South East (292/551,737)" 
"South West (341/578,496)" 
"West Midlands (349/520,826)" 
"Yorkshire & Humber (94/191,202)" 
end 
meta set slope slope_se, studylab(region) 
meta summarize, random(sjonkman) se(khartung) predinterval(95) 
meta forestplot, random(sjonkman) se(khartung) predinterval(95) xline(1) 
graph save "Graph" "\\graphs\ep2_cox\EP2_slope_cox.gph", replace  
clear 

 
use "\\estimates\citl_EP2regioncox.dta" , clear  
input str50 region 
"East Midlands (138/176,360)" 
"East of England (143/227,079)" 
"London (458/1,690,339)" 
"North East (77/98,275)" 
"North West (505/815,303)" 
"South Central (307/625,953)" 
"South East (292/551,737)" 
"South West (341/578,496)" 
"West Midlands (349/520,826)" 
"Yorkshire & Humber (94/191,202)" 
end 
meta set citl citl_se, studylab(region) 
meta summarize, random(sjonkman) se(khartung) predinterval(95) 
meta forestplot, random(sjonkman) se(khartung) predinterval(95) xline(0) 
graph save "Graph" "\\graphs\ep2_cox\EP2_citl_cox.gph", replace  
clear 
 

use "\\estimates\D_EP2regioncox.dta" , clear  
input str50 region 
"East Midlands (138/176,360)" 
"East of England (143/227,079)" 
"London (458/1,690,339)" 
"North East (77/98,275)" 
"North West (505/815,303)" 
"South Central (307/625,953)" 
"South East (292/551,737)" 
"South West (341/578,496)" 
"West Midlands (349/520,826)" 
"Yorkshire & Humber (94/191,202)" 
end 
meta set D D_se, studylab(region) 
meta summarize, random(sjonkman) se(khartung) predinterval(95) 
meta forestplot, random(sjonkman) se(khartung) predinterval(95) 
graph save "Graph" "\\graphs\ep2_cox\EP2_D_cox.gph", replace  
clear 

 
use "\\estimates\R2_EP2regioncox.dta" , clear  
input str50 region 
"East Midlands (138/176,360)" 
"East of England (143/227,079)" 
"London (458/1,690,339)" 
"North East (77/98,275)" 
"North West (505/815,303)" 
"South Central (307/625,953)" 
"South East (292/551,737)" 
"South West (341/578,496)" 
"West Midlands (349/520,826)" 
"Yorkshire & Humber (94/191,202)" 
end 
meta set R2 R2_se, studylab(region) 
meta summarize, random(sjonkman) se(khartung) predinterval(95) 
meta forestplot, random(sjonkman) se(khartung) predinterval(95)  
graph save "Graph" "\\graphs\ep2_cox\EP2_R2_cox.gph", replace  
clear 


use "\\estimates\Brier_EP2regioncox.dta" , clear  
input str50 region 
"East Midlands (138/176,360)" 
"East of England (143/227,079)" 
"London (458/1,690,339)" 
"North East (77/98,275)" 
"North West (505/815,303)" 
"South Central (307/625,953)" 
"South East (292/551,737)" 
"South West (341/578,496)" 
"West Midlands (349/520,826)" 
"Yorkshire & Humber (94/191,202)" 
end 
meta set Brier Brier_se, studylab(region) 
meta summarize, random(sjonkman) se(khartung) predinterval(95) 
meta forestplot, random(sjonkman) se(khartung) predinterval(95)  
graph save "Graph" "\\graphs\ep2_cox\EP2_Brier_cox.gph", replace  
clear 

******************************************************************************** 
******************************************************************************** 

***************************** 
* Smoothed calibration plot * 
***************************** 

use "\\data\final_datasets\Endpoint_2\OX129_endpoint2_imputed_IECV.dta", clear  
  
* Need to convert to wide (to use average iecv_xb), plot graph, close without saving *   
mi extract 0  

* Pseudovalues for failure function in Period 2 data - 'observed' event probs *  
stpsurv if period==2, failure at(10) gen(period2_pseudo) 
summ period2_pseudo, det   
gen iecv_risk = 1 - period1_baseline_surv_cox^exp(iecv_xb) 
summ iecv_risk, det  
drop if iecv_risk==. 

* Predicted probabilities - use the IECV-estimate linear predictors and combined with baseline  
* survival function estimated in Period 2 data earlier *  

running period2_pseudo iecv_risk, ci leg(off) nopts ysc(range(0 0.17)) xsc(range(0 0.17))  //
ylab(0(0.05)0.17) xlab(0(.05)0.15) title("Smoothed calibration plot - Cox proportional hazards model", size(small)) //
xtitle("Predicted event probability") ytitle("Observed event probability") graphregion(color(white))  

graph save "Graph" "\\graphs\ep2_cox\EP2_cox_smoothed_calibration.gph", replace  



clear all 

**************************************************************************************
************************************* END ********************************************
**************************************************************************************

 * 
